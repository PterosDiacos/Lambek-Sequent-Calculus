'''Utilities for translating lambek calculus proof tree
into Bussproofs Latex code.

Use `tobuss` function:
    - `con`:        conclusion
    - `pres`:       a list of premises
    - `cache`:      a dictionary that maps reduction laws to atom links.
                    Generated by `findproof` in `lbnoprod` and `displace`.
                    Accessible at `LambekProof` or `DisplaceProof` instances.
    - `trace`:      a list that traces proof search.
                    Generated by `findproof` in `lbnoprod` and `displace`.
                    Accessible at `LambekProof` or `DisplaceProof` instances.
'''

import re


ESCAPE_MAP = {'\\': '\\textbackslash ',
              '^': '$\\uparrow$',
              '!': '$\\downarrow$',
              '$': '$_{\\$}$',
              '&': '$_{\\&}$'}


def trans_term(s,
    pat0=re.compile(r'(?<=\A)-(?=\Z)'),
    pat1=re.compile('|'.join(re.escape(c) for c in ESCAPE_MAP)),
    pat2=re.compile(r'_(\d+)')):

    s = pat0.sub('[]', s)
    s = pat1.sub(lambda m: ESCAPE_MAP[m.group(0)], s)
    s = pat2.sub(lambda m: '$_{%s}$' % m.group(1), s)
    return s


def trans_law(con, pres):
    trans_pres = map(trans_term, pres)
    trans_con = trans_term(con) 
    return '%s $\\to$ %s' % (
        '\\enskip{}'.join(trans_pres), trans_con)


def axiom_line(con, pres, indent=''):
    return '%s\\AXC{%s}\n' %  (
        indent, trans_law(con, pres))


def unary_infer(above, con, pres, indent=''):
    return '%s%s\\UIC{%s}\n' % (
        above, indent, trans_law(con, pres))


def binary_infer(above1, above2, con, pres, indent=''):
    return '%s%s%s\\BIC{%s}\n' % (
        above1, above2, indent, trans_law(con, pres))


def toBuss(con, pres, cache, tree, indent='', space=' ' * 4):
    res = ''
    key = con, *pres
    for links in cache[key]:
        if not indent:
            s = sorted('(%s, %s)' % (i, j) for (i, j) in links)
            res += ', '.join(s) + '\n' + '-' * 10 + '\n'
            res += '\\begin{prooftree}\n\\EnableBpAbbreviations\n'
        if (key, links) in tree:
            if len(tree[key, links]) == 2:
                sub1, sub2 = tree[key, links]
                res += binary_infer(
                    toBuss(sub1[0], sub1[1:], cache, tree, indent + space),
                    toBuss(sub2[0], sub2[1:], cache, tree, indent + space),
                    con, pres, indent)
            elif len(tree[key, links]) == 1:
                sub, = tree[key, links]
                res += unary_infer(
                    toBuss(sub[0], sub[1:], cache, tree, indent + space),
                    con, pres, indent)
        else:
            res += axiom_line(con, pres, indent)
        if not indent:
            res += '\\end{prooftree}\n\n'

    return res
